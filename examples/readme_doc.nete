{
	"name":	"readme_doc.nete",
	"fileName":	"",
	"destination":	"README.md",
	"topNode":	-1,
	"zoomScaleFactor":	1,
	"node_group":	[{
			"x":	120,
			"y":	120,
			"width":	850,
			"height":	490,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	-1,
			"contained":	[1, 2, 18, 19, 20, 21],
			"priority":	5,
			"name":	"Implementation",
			"description":	"",
			"head":	"# NETE",
			"tail":	"",
			"real_code":	"",
			"node_id":	0
		}, {
			"x":	160,
			"y":	10,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	0,
			"contained":	[],
			"priority":	1,
			"name":	"intro",
			"description":	"",
			"head":	"## Introduction",
			"tail":	"",
			"real_code":	"Computer programs are normally written as plain text documents, usually as a long trail of lines from top to bottom. I think it would be a nice touch if an artistic dimension could be added to that code to enhance meaning.\n\nNETE, meaning New Era Text Editor, is a way in which the programmer can embed a diagrammatic overview to the code and thus summarise the underlying operations better. It uses a graphical approach to creating and editing text. Graphical here is capturing two senses of the word i.e. \n\n1. Drawing pictures on a screen,\n2. Mathematical nodes and arcs.\n\nThe entire proposition is carried by the two elements i.e. node and arc, and how these are creatively combined to produce the intended output in a project.",
			"node_id":	1
		}, {
			"x":	20,
			"y":	170,
			"width":	610,
			"height":	220,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	0,
			"contained":	[8, 3, 9],
			"priority":	5,
			"name":	"How it Works",
			"description":	"",
			"head":	"## How it Works",
			"tail":	"",
			"real_code":	"",
			"node_id":	2
		}, {
			"x":	10,
			"y":	10,
			"width":	150,
			"height":	180,
			"next":	8,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	2,
			"contained":	[4, 5],
			"priority":	5,
			"name":	"Nodes",
			"description":	"",
			"head":	"## Nodes",
			"tail":	"",
			"real_code":	"",
			"node_id":	3
		}, {
			"x":	20,
			"y":	10,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	3,
			"contained":	[],
			"priority":	0,
			"name":	"Overview",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"The nodes carry the bulk of the work in making all the magic happen. The same node is used in two scenarios:\n\n\n1. To carry text (where it's termed a codebox),\n2. To carry nodes (where it's termed a container).\n\n\nThe same one node does both jobs but in different scenarios. The determinant is whether or not it contains another node and this difference shows up during rendering.\n\nNodes also carry with them two other visible features, which are title and priority. A description field is included and this is more or less a comment feature with no real consequence on operations.",
			"node_id":	4
		}, {
			"x":	20,
			"y":	70,
			"width":	150,
			"height":	130,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	3,
			"contained":	[6, 7],
			"priority":	5,
			"name":	"Codebox",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"",
			"node_id":	5
		}, {
			"x":	20,
			"y":	10,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	5,
			"contained":	[],
			"priority":	5,
			"name":	"Head, Tail and Textbox",
			"description":	"",
			"head":	"### Codebox - Head, Tail and Textbox",
			"tail":	"",
			"real_code":	"Codebox structure             |  Real CodeBox\n:-------------------------:|:-------------------------:\n![Codebox Structure](/images/codebox_struct.png) | ![Codebox Example](/images/codeboxwithcode2.png)\n\nOn the inside of a node there are three other important text fields, which are the head, tail and textbox. These are pertinent for the actual low level of operations and they form the basis of the text. Upon rendering a codebox, these elements are batched in the order:\n\n\n1. Head,\n2. Textbox,\n3. Tail.\n\n\nThe head and tail are very important for containers because they allow an operator to be bound to the contained nodes.\n\nThe head and tail can also be useful in helping maintain codebox scope, because they allow mandatory fields to be taken out of the core code at hand and be maintained separately. An example could be a ``for`` statement where the head would contain \n````javascript \n\t\tfor(i = 0; i < 10; i++) { \n  ```` \n  and the tail may have ``}`` then the body is in the textbox. That way the programmer can focus their attention better on the body without being distracted by the syntax of the ``for``.\n  \nThe textbox is meant to carry small manageable snippets of code. This is where the bulk of the text is carried in the project. The size of this snippet is up to the discretion of the programmer. The idea here being that it must be a simple enough section to read through and understand in a short space of time.",
			"node_id":	6
		}, {
			"x":	20,
			"y":	60,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	5,
			"contained":	[],
			"priority":	5,
			"name":	"Container",
			"description":	"",
			"head":	"### Container",
			"tail":	"",
			"real_code":	"In the case of a container, every aspect of the codebox applies, except that the textbox is ignored. This is because the role of the textbox is taken by the contained nodes and these contained nodes are rendered recursively to eventually produce the contained text.\n\nContainers may act as passive holders of nodes purely for logical grouping or they can apply an operator to those nodes that they contain. An example of such could be a ``for`` loop, a ``while`` operator, an ``if`` statement, e.t.c. This comes about because the head and tail give containers the ability to hold scope over the nodes that they contain.",
			"node_id":	7
		}, {
			"x":	200,
			"y":	60,
			"width":	100,
			"height":	20,
			"next":	9,
			"previous":	3,
			"cont_head":	-1,
			"cont_by":	2,
			"contained":	[],
			"priority":	5,
			"name":	"Arcs",
			"description":	"",
			"head":	"## Arcs",
			"tail":	"",
			"real_code":	"![Nodes joined by arcs](/images/nodesfollowing2.png)\n\nThe arc is present to allow a follow sequence to be determined and it outputs from the right of a node and inputs into the left of the follower.",
			"node_id":	8
		}, {
			"x":	330,
			"y":	20,
			"width":	260,
			"height":	160,
			"next":	-1,
			"previous":	8,
			"cont_head":	-1,
			"cont_by":	2,
			"contained":	[10, 11, 12, 13, 14, 15],
			"priority":	5,
			"name":	"Putting it Together",
			"description":	"",
			"head":	"## Putting it Together",
			"tail":	"",
			"real_code":	"",
			"node_id":	9
		}, {
			"x":	20,
			"y":	10,
			"width":	100,
			"height":	20,
			"next":	11,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	9,
			"contained":	[],
			"priority":	5,
			"name":	"Relations",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"\n![Nodes of different priorities in a container](/images/nodesandcontainer2.png)\n\nThe relationship between codeboxes, containers and arcs then comes together during rendering. Here a few simple rules determine the outcome. Text in the output comes from three sources, which are:\n\n\n1. Heads,\n2. Textboxes,\n3. Tails.\n",
			"node_id":	10
		}, {
			"x":	140,
			"y":	10,
			"width":	100,
			"height":	20,
			"next":	12,
			"previous":	10,
			"cont_head":	-1,
			"cont_by":	9,
			"contained":	[],
			"priority":	5,
			"name":	"Render Start",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"\nWhen the system renders a node, it begins with the head. Then depending on whether it's a codebox or a container it will render the textbox or the contained nodes recursively and lastly renders the tail.",
			"node_id":	11
		}, {
			"x":	20,
			"y":	60,
			"width":	100,
			"height":	20,
			"next":	13,
			"previous":	11,
			"cont_head":	-1,
			"cont_by":	9,
			"contained":	[],
			"priority":	5,
			"name":	"picking",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"In order to render a node it has to pick the node and have a reason to move to the next node. Everything starts from the first node. The first node is found at the highest level of nodes i.e. nodes which are not contained by any other nodes. Nodes at any equal level in a container are then ordered by priority and ordered by followings (i.e. arcs).",
			"node_id":	12
		}, {
			"x":	140,
			"y":	60,
			"width":	100,
			"height":	20,
			"next":	14,
			"previous":	12,
			"cont_head":	-1,
			"cont_by":	9,
			"contained":	[],
			"priority":	5,
			"name":	"priority",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"\n![Nodes set to show the colour coded priorities](/images/colour_codes2.png)\n\nThe nodes may have 10 priorities as shown in the figure, so this feature must be used sparingly. Priority 0 is the highest and 9 is the lowest. With nodes at the same level the highest priority is rendered first and the lowest is rendered last. The priority is visible as a colour code on the frame of the node. Nodes which have the same priority, at the same level of a container can be considered to be picked in random order(useful for parallel thinking).",
			"node_id":	13
		}, {
			"x":	20,
			"y":	110,
			"width":	100,
			"height":	20,
			"next":	15,
			"previous":	13,
			"cont_head":	-1,
			"cont_by":	9,
			"contained":	[],
			"priority":	5,
			"name":	"following",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"\nArc following is the other rule which determines ordering or rendering. Here the system will follow the arcs in its path.",
			"node_id":	14
		}, {
			"x":	140,
			"y":	110,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	14,
			"cont_head":	-1,
			"cont_by":	9,
			"contained":	[],
			"priority":	5,
			"name":	"render",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"Using this simple set of rules, the system will stitch together all the text contained in the nodes and give out a rendered text file to be used as desired. ",
			"node_id":	15
		}, {
			"x":	20,
			"y":	20,
			"width":	100,
			"height":	20,
			"next":	17,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	18,
			"contained":	[],
			"priority":	5,
			"name":	"How to Run it",
			"description":	"",
			"head":	"## How to Run it",
			"tail":	"",
			"real_code":	"So far this progam has been tested on Linux x86 and Raspberry Pi. The code requires GTK3, libgtksourceview and some other few packages to compile. I acquired them with the command:\n````\nsudo apt-get install build-essential libgtk-3-dev libgtksourceview-3.0-dev\n````\nThen compile the source by running:\n````\nmake\n````\nThen the program can be run with the command:\n````\n./nete_exec\n````",
			"node_id":	16
		}, {
			"x":	150,
			"y":	20,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	16,
			"cont_head":	-1,
			"cont_by":	18,
			"contained":	[],
			"priority":	5,
			"name":	"quick start",
			"description":	"",
			"head":	"## Quick Start",
			"tail":	"",
			"real_code":	"When the program starts it has a very simple interface which has a toolbar and a canvas.\n\n![Interface on start](/images/typicalinterface.png)\n\nThe toolbar has an entry box for finding line numbers and three radio buttons for the editing mode, which are: ``Move``, ``Contain`` and ``Link``.\n\n* ``Move`` allows the nodes to be moved and resized. Moving is done by dragging the name tag. Resizing is achieved by dragging the square shaped resize grip on the bottom right corner.\n* ``Contain`` allows nodes to be put into containers. This is done by clicking the name tag of the node to move. At this point the name tag should take on a blue background. Then the next step is to select a point in the body of the destination node.\n* ``Link`` will connect to nodes with an arc. This is done by clicking in the body of the first node. The name tag will be highlighted in blue, then click in the body of the node to follow. An arc should appear linking the two. Removing an  arc is the same process on already connected nodes.\n\n![A selected node](/images/nodehighlight.png)\n\nDouble clicking the name tag opens a window in which details of that node can be edited.\n\nNew nodes can be created by right clicking at a desired location in the canvas and selecting **New Node**. Nodes created in the body of another node are automatically contained by that node.\n\nNodes can be copied and pasted simply by right clicking on the name tag and selecting **Copy**, then right clicking on an intended destination and selecting **Paste**. A node is copied along with all the other contents it carries.\n\nBy default, output text is written to the file **nete_out.txt**. This can be changed under **Edit** then **Option** on the top menu. A window with an entry box will appear where a complete path to a desired output file can be entered.\n\nWhenever the text represented by NETE is required, the output file can be rendered under **File** then **Render** or by pressing **CTRL+SHIFT+R**.",
			"node_id":	17
		}, {
			"x":	20,
			"y":	60,
			"width":	280,
			"height":	80,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	0,
			"contained":	[16, 17],
			"priority":	2,
			"name":	"In Use",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"",
			"node_id":	18
		}, {
			"x":	240,
			"y":	440,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	0,
			"contained":	[],
			"priority":	7,
			"name":	"Acknowledgements",
			"description":	"",
			"head":	"## Acknowledgements",
			"tail":	"",
			"real_code":	"This project uses the following libraries in its operations:\n\n* **cJSON** by Dave Gamble, from https://github.com/DaveGamble/cJSON\n* **dynarray** from https://github.com/eignnx/dynarray",
			"node_id":	19
		}, {
			"x":	660,
			"y":	170,
			"width":	130,
			"height":	40,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	0,
			"contained":	[],
			"priority":	6,
			"name":	"Example",
			"description":	"",
			"head":	"## Example",
			"tail":	"",
			"real_code":	"This README is a typical example of NETE in real life operation. The overview is shown in the figure below and the _.nete_ file is available in the **examples** folder.\n\n![README.md NETE overview](/images/neteexample3.png)",
			"node_id":	20
		}, {
			"x":	30,
			"y":	10,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	0,
			"contained":	[],
			"priority":	0,
			"name":	"Logo",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"![NETE logo](/images/nete_logo.png)",
			"node_id":	21
		}, {
			"x":	1270,
			"y":	580,
			"width":	100,
			"height":	20,
			"next":	-1,
			"previous":	-1,
			"cont_head":	-1,
			"cont_by":	-1,
			"contained":	[],
			"priority":	5,
			"name":	"misc",
			"description":	"",
			"head":	"",
			"tail":	"",
			"real_code":	"",
			"node_id":	22
		}]
}
